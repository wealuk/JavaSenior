package com.atguigu.java;

/**复习
 * 1.线程的生命周期:
 * 新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建 状态
 * 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源
 * 运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线 程的操作和功能
 * 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态
 * 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束
 *
 * 还要掌握线程各个状态之间转换使用的方法--->见笔记图线程的生命周期
 *
 *说明：1.生命周期关注两个概念：状态、相应的方法
 *      2.关注：状态a-->状态b：哪些方法执行了（回调方法）----以后关注
 *              某个方法主动调用：状态a-->状态b----现在理解
 *
 *
 * 2.释放锁的操作：
 * 当前线程的同步方法、同步代码块执行结束。
 * 当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、 该方法的继续执行。
 * 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导
 * 致异常结束。
 * 当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线 程暂停，并释放锁。
 *
 * 3.不会释放锁的操作：
 * 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、
 * Thread.yield()方法暂停当前线程的执行*************yield会使线程从运行变成就绪，但不会释放锁
 *
 * 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程
 * 挂起，该线程不会释放锁（同步监视器）。
 * 应尽量避免使用suspend()和resume()来控制线程
 *
 * @author shkstart
 * @create 2021-04-08 13:04
 */
public class Thread13 {
}
